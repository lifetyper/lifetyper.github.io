<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>LifeTyper</title><link href="/" rel="alternate"></link><link href="atom.xml" rel="self"></link><id>/</id><updated>2019-11-23T11:45:00+08:00</updated><entry><title>使用Ghostunnel建立TLS加密隧道</title><link href="posts/use_ghostunnel_to_create_secure_tls_tunnel.html" rel="alternate"></link><published>2019-11-23T11:45:00+08:00</published><updated>2019-11-23T11:45:00+08:00</updated><author><name>毕勤</name></author><id>tag:None,2019-11-23:posts/use_ghostunnel_to_create_secure_tls_tunnel.html</id><summary type="html">&lt;p&gt;我一直感到很奇怪的一点是，TLS在当今各种翻墙工具中被大量使用，但却很少看到单纯的tls隧道的搭建的文章，甚至连这类工具的介绍都很少。&lt;/p&gt;</summary><content type="html">&lt;p&gt;我一直感到很奇怪的一点是，TLS在当今各种翻墙工具中被大量使用，但却很少看到单纯的tls隧道的搭建的文章，甚至连这类工具的介绍都很少。&lt;/p&gt;
&lt;h2&gt;惨痛的现实&lt;/h2&gt;
&lt;p&gt;刚好最近这段时间高墙又有些新动作，我暂时观察到的解决办法就是tls混淆，当然，真正的TLS也可以。猜测是TLS1.3之后各种证书拦截和检测的成本已经高的不可思议，他们暂时对TLS只能放弃治疗，甚至连假的混淆也直接放过。当然也可能他们只是封锁不明协议，只要看着还像个正常的协议，就都给放行，这个似乎更合理一些。&lt;/p&gt;
&lt;p&gt;考虑到SSR已经基本停止开发，SS似乎是因为历史问题对tls混淆嗤之以鼻，v2ray的检测专利大家也都看到了，觉得有必要好好研究一下纯粹的TLS加密隧道的搭建。搭配完成的TLS隧道，其实最后用什么工具都很好办，哪怕是ss原版配合none加密也不是问题，因为TLS本身就是强加密的。&lt;/p&gt;
&lt;p&gt;找了一圈最后找到了&lt;a href="https://github.com/square/ghostunnel"&gt;ghostunnel&lt;/a&gt;,其实他是个stunnel的替代品，基于go语言开发。为什么不写stunnel的？因为很多很多年前就有人写过了。&lt;/p&gt;
&lt;h2&gt;证书管理部分&lt;/h2&gt;
&lt;p&gt;其实tls隧道最复杂的并不是隧道本身的搭建，而是一大堆证书的生成和管理。你可以直接选择购买ssl证书拿来用，但我个人认为这没有必要。使用私有CA授权的证书和过期证书的网站和服务器在网络上比比皆是，单从伪装角度讲，商业证书未必有什么优势，墙不会因为你花钱买了EV级证书就对你网开一面。&lt;/p&gt;
&lt;p&gt;证书管理工具我选择了&lt;a href="https://github.com/square/certstrap"&gt;certstrap&lt;/a&gt;,下面是几个关键步骤。&lt;/p&gt;
&lt;h3&gt;生成根证书&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;certstrap init --common-name &amp;quot;CA&amp;quot; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的common-name是必须的，具体名字你可以自己定，这个命令会生成CA.crt、CA.csr、CA.key这三个文件，&lt;/p&gt;
&lt;h3&gt;合并根证书为pem文件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat CA.crt CA.key &amp;gt;CA.pem
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很简单，就是把key和cert直接拼起来生成一个包含了二者的pem文件，因为ghostunnel需要使用这样的格式的CA。&lt;/p&gt;
&lt;h3&gt;为节点（客户端、服务器）生成key&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;certstrap request-cert --domain cn.ssr.org
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里根据实际域名填写，分别是客户端和服务器端的域名，这会生成cn.ssr.org.key 和cn.ssr.org.csr 两个文件。&lt;/p&gt;
&lt;h3&gt;用根证书为节点签发证书&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;certstrap sign cn.ssr.org --CA CA 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的CA就是我们刚才生成的根证书的名字，这会生成cn.ssr.org.crt&lt;/p&gt;
&lt;h3&gt;生成合并的pkcs12格式keystore文件&lt;/h3&gt;
&lt;p&gt;其实到这里本来就够了，为了方便使用，我们可以生成一个合并的包含了公私钥的keystore文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;openssl pkcs12 -export -out cn.p12 -inkey cn.ssr.org.key -in cn.ssr.org.crt -certfile CA.crt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样会得到一个cn.p12的keystore文件，注意，国内节点（客户端）和国外节点（服务器）都要生成这些证书。&lt;/p&gt;
&lt;h3&gt;最终的文件&lt;/h3&gt;
&lt;p&gt;假定我们的国内节点是cn.ssr.org，国外节点是x.ssr.org，我们最终得到了用于国内节点的cn.ssr.org.key、cn.ssr.org.csr(用不上)、cn.ssr.org.crt、cn.p12文件，以及用于国外节点的x.ssr.org.key、x.ssr.org.csr（用不上）、x.ssr.org.crt、x.p12文件。&lt;/p&gt;
&lt;h2&gt;测试框架&lt;/h2&gt;
&lt;p&gt;我们在国外的服务器(x.ssr.org)上运行一个简单的http服务器，但只监听localhost的8001端口并不开放给公网。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 -m http.server 8001 --bind 127.0.0.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在国外服务器上运行ghostunnel的服务器端，从服务器端的0.0.0.0:8002端口转发到服务器的localhost:8001端口。
在国内服务器运行ghostunnel的客户端，从客户端的0.0.0.0:8003转发到服务器的0.0.0.0:8002端口。
本来如果没有隧道直接访问，路径应该是这样的：
client--HTTP--&amp;gt;x.ssr.org:8001
现在有了TLS隧道后，最终路径是这样的:
client--HTTP--&amp;gt;cn.ssr.org:8003--&amp;gt;TLS--&amp;gt;x.ssr.org:8002--HTTP--&amp;gt;x.ssr.org:8001
也就是说，对客户端（浏览器）和最终的服务端（http server）来说，完全不需要做任何改变，依然可以使用它原来不安全的http协议明文传送，但从cn.ssr.org到x.ssr.org的这个跨国链路，就是完全TLS加密的了，为什么这样做我想不用解释了。&lt;/p&gt;
&lt;h2&gt;Ghostunne服务器配置&lt;/h2&gt;
&lt;p&gt;假设我们生成的证书全部放在一个out目录下，服务器运行参数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ghostunnel server \
    --listen 0.0.0.0:8002 \
    --target localhost:8001 \
    --key out/x.ssr.org.key \
    --cert out/x.ssr.org.crt \
    --cacert out/CA.pem \
    --allow-all
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面这是分别制定key和cert文件的，我们也可以使用合并的keystore文件，命令就变成这样了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ghostunnel server \
    --listen 0.0.0.0:8002 \
    --target localhost:8001 \
    --keystore out/x.p12 \
    --cacert out/CA.pem \
    --allow-all
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的--allow-all表示允许所有客户端连接，也可以通过指定域名证书的方式，限制特定IP（域名）来源的连接，配合自己的私有CA证书，非授权的机器几乎不可能连上服务器。
指定域名的用法是：
把--allow-all替换成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;--allow-cn cn.ssr.org
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Ghostunnel客户端配置&lt;/h2&gt;
&lt;p&gt;同样的，分别使用key和cert文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ghostunnel client \
    --listen 0.0.0.0:8003 \
    --target x.ssr.org:8002 \
    --key out/cn.ssr.org.key \
    --cert out/cn.ssr.org.crt \
    --cacert out/CA.pem \
    --unsafe-listen
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用合并的keystore文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ghostunnel client \
    --listen 0.0.0.0:8003 \
    --target x.ssr.org:8002 \
    --keystore out/cn.p12 \
    --cacert out/CA.pem \
    --unsafe-listen
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打完收工。平时如果直接从国内访问国外机器的http端口并且传大量文件，很快就会被rst了，现在我们可以通过国内的cn.ssr.org:8003端口+TLS隧道来访问，实测下来下载几个G的文件也没什么发生，速度还挺稳定。&lt;/p&gt;</content></entry><entry><title>为Pelican Blog添加Json Feed</title><link href="posts/add_json_feed_to_pelican_blog.html" rel="alternate"></link><published>2019-09-02T13:54:53+08:00</published><updated>2019-09-02T13:54:53+08:00</updated><author><name>毕勤</name></author><id>tag:None,2019-09-02:posts/add_json_feed_to_pelican_blog.html</id><summary type="html">&lt;p&gt;不废话，只是记录一下。json feed比atom和rss feed真的好用太多了，爬虫看到这个估计都要感动的哭起来，用wget都能写爬虫了。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;为Pelican添加Plugins目录&lt;/h2&gt;
&lt;p&gt;找到你的pelicanconf.py文件，在同路径添加一个plugins目录（名字可以改），然后从&lt;a href="https://github.com/andrewheiss/pelican_json_feed"&gt;这里&lt;/a&gt;clone这个插件过来到plugins目录。&lt;/p&gt;
&lt;h2&gt;编辑pelicanconf.py配置&lt;/h2&gt;
&lt;p&gt;为了让pelican工程认到这个插件，需要编辑pelicanconf.py文件，添加以下内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#Plugins
PLUGIN_PATHS = [&amp;#39;plugins&amp;#39;]
PLUGINS = [&amp;#39;pelican_json_feed&amp;#39;]
FEED_ALL_JSON = &amp;#39;feeds.json&amp;#39;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;FEED_ALL_JSON的文件名可以自己定义。&lt;/p&gt;
&lt;h2&gt;修一个小bug&lt;/h2&gt;
&lt;p&gt;打开插件的json_feed.py文件，这个项目真的有点老了，json.dump函数现在只接受两个参数，不知道这个工程写的时候是不是参数都不一样，把最后一个encode参数删掉才行，否则会爆错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    def write(self, fp, encoding=&amp;#39;utf-8&amp;#39;):
        json.dump(self.feed, fp)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;编辑blog模板&lt;/h2&gt;
&lt;p&gt;服务爬虫，更容易的找到你的json_feed，在base.html模板的header中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;FEED_ALL_JSON&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;&amp;lt;link rel=&amp;quot;alternate&amp;quot; type=&amp;quot;application/json&amp;quot; title=&amp;quot;JSON Feed&amp;quot; href=&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;FEED_DOMAIN&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;/&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;FEED_ALL_JSON&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后重新发布，好了。&lt;/p&gt;</content></entry><entry><title>基于ZeroTier和Openwrt路由器的内网互访方案</title><link href="posts/access_remote_lan_through_zerotier.html" rel="alternate"></link><published>2019-04-24T17:11:30+08:00</published><updated>2019-04-24T17:11:30+08:00</updated><author><name>毕勤</name></author><id>tag:None,2019-04-24:posts/access_remote_lan_through_zerotier.html</id><summary type="html">&lt;p&gt;相信这个标题就已经很吸引人了，因为很多人都有类似的需求，在家里访问公司服务器或工作机的内容，在公司访问家里服务器的数据，本文讨论的就是这个目的的实现。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;方案选择&lt;/h2&gt;
&lt;p&gt;现在用的方案里，无非是两种，一种是像&lt;a href="https://github.com/fatedier/frp/"&gt;FRP&lt;/a&gt;这样的基于公网服务器进行端口转发的，这个有一个门槛是必须有一个公网VPS，速度要快的话自然是国内VPS最好，但国内的VPS带宽价格却是最贵的。而且当你需要转发多个同类型服务时，还需要记忆一大堆的端口，对于一些不支持自定义端口的app来说更是痛苦。&lt;/p&gt;
&lt;p&gt;另一种就是类似n2n或者&lt;a href="https://zerotier.com/"&gt;zerotier&lt;/a&gt;这样的打洞方式，本质是利用中转服务器牵线，最终建立二者间的直连，而且zerotier在直连失败的情况下依然可以提供中转服务，稳定性和速度都很优秀。实际测下来从公司到家里的网络间延迟大约只有10ms，排掉各级网络设备本身的延迟，应该就是直连了。&lt;/p&gt;
&lt;h2&gt;网络拓扑和最终效果&lt;/h2&gt;
&lt;p&gt;目前我在公司和家里的网络情况如下
&lt;img alt="Zerotier network topo" src="images/zt_network_topo.jpg"&gt;
当然，公司是我自己接了一级路由后的结果，毕竟公司的路由器不受我控制。我在公司的内网网段是192.168.88.0/24,在家的内网网段是192.168.99.0/24，最终的效果就是我在公司可以直接用IP访问192.168.99.0/24网段的设备，在家可以用IP直接访问192.168.88.0/24网段的设备，看起来就像两个网段被物理桥接在一起一样，完全就是个虚拟局域网。&lt;/p&gt;
&lt;p&gt;注意，两地的局域网网段不能一样，否则后面没法搞，连路由表都没法写。&lt;/p&gt;
&lt;h2&gt;使用的设备和服务&lt;/h2&gt;
&lt;p&gt;两台刷了lede并有zerotier插件的路由器，注册一个zerotier账号，硬件要求就这么多了。&lt;/p&gt;
&lt;p&gt;其他门槛：智商。&lt;/p&gt;
&lt;h2&gt;配置zerotier账号&lt;/h2&gt;
&lt;p&gt;账号本身没什么，就是注册登陆后建立一个zerotier网络，这里建议设置成private network，这样别人就不能随便加入了。&lt;/p&gt;
&lt;h3&gt;授权自己的接入点&lt;/h3&gt;
&lt;p&gt;因为设置成了private network，所以默认是无法加入这个网络的，但你可以在zerotier的&lt;a href="https://my.zerotier.com/network/"&gt;网络管理界面&lt;/a&gt;看到哪些点，然后在auth上勾选一下，就授权了这个点接入了。&lt;/p&gt;
&lt;h3&gt;设置分配IP的网段&lt;/h3&gt;
&lt;p&gt;其实不设置根本没问题，你只要设置好路由表保证分配的网段范围都划分到同一个lan就行。我这个纯粹是强迫症而已，你们可以不设置，但如果担心有什么灵异事情发生导致不好解释的话（有什么不好解释的，就是你路由表错了呗），设置成同一个C段吧，反正最后你两地的IP要能互相ping通就行。&lt;/p&gt;
&lt;p&gt;反正我这里设置成了10.242.100.1~10.242.100.254，保证这个IP段不和你两端任意一段路由器的LAN IP段冲突就行。&lt;/p&gt;
&lt;h3&gt;设置zerotier的路由表&lt;/h3&gt;
&lt;p&gt;这个是最重要的地方，参考我上面的网络拓扑，我的路由表如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;10.242.0.0/16 (LAN)
192.168.88.0/24 via 10.242.100.216
192.168.99.0/24 via 10.242.100.121
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一个表示10.242.0.0/16这是同一个局域网，你们分配IP在这个范围的直连就行了，不用过别的网关了。&lt;/p&gt;
&lt;p&gt;第二条也很好理解，公司的路由器后网段是192.168.88.0/24，而公司路由器上的zerotier分配到的IP是10.242.100.216(这个可以在zerotier网站查，也可以通过ifconfig命令在路由器查)，那么zerotier局域网内的其他IP要访问这个192.168.88.0/24网段的话，自然要通过10.242.100.216作为网关。&lt;/p&gt;
&lt;p&gt;第三条就完全是第二条的家庭版，不解释了。&lt;/p&gt;
&lt;p&gt;注意，这个只是告诉了zerotier局域网内的路由表，但这个路由表并不会广播到你的路由器上，你必须在路由器上设置好才行。&lt;/p&gt;
&lt;h2&gt;路由器的设置&lt;/h2&gt;
&lt;h3&gt;启动并连接zerotier&lt;/h3&gt;
&lt;p&gt;这个简单到爆，看图
&lt;img alt="config_zerotier_on_lede" src="images/config_zerotier_on_lede.png"&gt;
勾选启用，填入你的zerotier nerwork ID，勾选允许自动NAT，保存应用，搞定。&lt;/p&gt;
&lt;h3&gt;查看Zerotier的状态&lt;/h3&gt;
&lt;p&gt;首先是查看zerotier虚拟网卡的名称，直接在路由器上输入ifconfig命令，看到一个zt开头的就是zerotier的虚拟网卡了，我这里的是：ztzlgmpcam。&lt;/p&gt;
&lt;p&gt;千万不要傻逼兮兮直接抄，算我提前求你们了，不对，不用求，反正我这里不支持评论，你们要自己挖坑就自己跳。&lt;/p&gt;
&lt;p&gt;另外，ifconfig命令也可以看到这个虚拟网卡是否分配到了IP，这个可以告知你zerotier是否成功连上了虚拟局域网。&lt;/p&gt;
&lt;p&gt;如果你的这台路由器从Zerotier分配到了IP A,而远端的路由器分配到了IP B，那么这个时候你从两端互相ping这个分配的IP应该是可以ping通的。&lt;/p&gt;
&lt;h3&gt;设置路由表&lt;/h3&gt;
&lt;p&gt;这可能是唯一有点技术含量的部分了，我们上面说了，zerotier网站上设置的路由表并不会广播到路由器上，经典台词：路怎么走，你们自己选。&lt;/p&gt;
&lt;p&gt;Update:其实这个原来是旧版本的zerotier openwrt插件的一个功能缺失，现在已经修复了，所以其实现在并不需要自己再添加路由表了，所以到这里其实工作已经完成了，下面不用再看了。&lt;/p&gt;
&lt;p&gt;而且静态路由表本来就不是最合理的做法，因为接口如果断开的话，路由表是无效的，但也不会有什么问题，因为不能访问还是不能访问，并不会有什么额外的问题。现在新版的插件中，应该是在ifup和ifdown的脚本中动态添加和删除路由表了，这个才是正确的做法。&lt;/p&gt;
&lt;h4&gt;动态版本&lt;/h4&gt;
&lt;p&gt;可以先用ip命令添加一下，测试一下是否成功，例如我们在公司的路由器上，要访问家里的192.168.99.0/24网段，家里的路由器分配的zerotier IP是10.242.100.121，那么命令是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ip route add 192.168.99.0/24 via 10.242.100.121
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用route命令可以查看到这样一条route记录&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.99.0    10.242.100.121  255.255.255.0   UG    0      0        0 ztzlgmpcam
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似的，在家里的路由器添加一条到公司192.168.88.0/24网段的路由表:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ip route add 192.168.88.0/24 via 10.242.100.216
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;添加后用route命令应该看到这样的一条路由表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.88.0    10.242.100.216  255.255.255.0   UG    0      0        0 ztzlgmpcam
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个时候，从双方局域网的任何一台设备，都应该可以直接访问双方局域网的任意一个IP了。&lt;/p&gt;
&lt;h4&gt;固化版本&lt;/h4&gt;
&lt;p&gt;上面的ip route命令虽然来得快，但一重启就没了，最稳妥的是直接写入config文件里。编辑/etc/config/network文件，公司版本的写法,在文件最末尾添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;config route
    option interface &amp;#39;ztzlgmpcam&amp;#39;
    option target &amp;#39;192.168.99.0/24&amp;#39;
    option gateway &amp;#39;10.242.100.121&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;家庭版本的写法，添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;config route
    option interface &amp;#39;ztzlgmpcam&amp;#39;
    option target &amp;#39;192.168.88.0/24&amp;#39;
    option gateway &amp;#39;10.242.100.216&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样的，根据你的实际情况，替换interface为你的zerotier虚拟网卡的名称，以及后面的目标网段，和目标网段上的路由器分配到的zerotier IP。&lt;/p&gt;
&lt;p&gt;然后/etc/init.d/network restart就可以生效了，这样的路由表重启后是不会丢失的。&lt;/p&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;其实想想看，这个方案并不一定需要ZeroTier，任何你可以自己配置路由表的VPN都是可以的，只是其他的VPN方案最终都是要过服务器绕一圈，并不一定能充分发挥最大的带宽，且稳定性受限于服务器。&lt;/p&gt;</content></entry><entry><title>利用SSR在国内服务器转发Telegram的MTProxy代理</title><link href="posts/use_ssr_to_redirect_mtproto_proxy_inside_gfw.html" rel="alternate"></link><published>2019-03-27T22:50:54+08:00</published><updated>2019-03-27T22:50:54+08:00</updated><author><name>毕勤</name></author><id>tag:None,2019-03-27:posts/use_ssr_to_redirect_mtproto_proxy_inside_gfw.html</id><summary type="html">&lt;p&gt;最近这段时间，Telegram的&lt;a href="https://github.com/TelegramMessenger/MTProxy"&gt;MTProxy&lt;/a&gt;可以说几乎是被判了死刑，原因无外乎是&lt;a href="https://github.com/TelegramMessenger/MTProxy#random-padding"&gt;MTProxy的数据包大小特征太明显&lt;/a&gt;，极其容易被分析出来。虽然官方加入了Random Padding这个功能试图解决这个问题，但效果其实非常可怜，我换完端口后开启了Random Padding，哪怕只有我一个人在用这个代理，依然在12小时内被封掉。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;糟糕的背景说明&lt;/h2&gt;
&lt;p&gt;最近这段时间，Telegram的&lt;a href="https://github.com/TelegramMessenger/MTProxy"&gt;MTProxy&lt;/a&gt;可以说几乎是被判了死刑，原因无外乎是&lt;a href="https://github.com/TelegramMessenger/MTProxy#random-padding"&gt;MTProxy的数据包大小特征太明显&lt;/a&gt;，极其容易被分析出来。虽然官方加入了Random Padding这个功能试图解决这个问题，但效果其实非常可怜，我换完端口后开启了Random Padding，哪怕只有我一个人在用这个代理，依然在12小时内被封掉。&lt;/p&gt;
&lt;p&gt;现在普遍的建议是在国内搭需要鉴权的socks5服务器，这个技术上没有问题，但如果你要分享出去的话，一个socks5代理可以做的，可不仅仅是MTProxy这么简单，需要承担的风险会大得多。&lt;/p&gt;
&lt;p&gt;这种情况，要么上专线搭MTProxy，要么就用更不容易被封的手段转发这个代理服务，不管是v2还是ssr，这个你根据自己的爱好选择，我习惯性的还是用ssr。&lt;/p&gt;
&lt;h2&gt;在国外VPS建立一个跳板代理&lt;/h2&gt;
&lt;p&gt;对我来说，这就是一台装了SSR的国外VPS而已。&lt;/p&gt;
&lt;h2&gt;在国内VPS建立一个透明代理&lt;/h2&gt;
&lt;p&gt;我们以ssr为例，这里需要用到的是ss(r)-redir，而不是ss(r)-local，后者是用于建立socks5代理的，而前者才是我们所需要的透明代理。具体的建立过程就不多说了，无非就是ss-redir -c config.json了，这里我设定的本地代理端口是127.0.0.1:1080。注意，不要开放到0.0.0.0上，否则你的透明代理可能会被滥用的。&lt;/p&gt;
&lt;h2&gt;建立转发规则&lt;/h2&gt;
&lt;p&gt;根据hostloc论坛网友的建议，只需要找出Telegram的3个ASN所对应的IP，把国内VPS到这些IP的流量全部转发到ss-redir产生的透明代理上就行了。&lt;/p&gt;
&lt;p&gt;写了个脚本把这些IP拔下来然后转成bash脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;

&lt;span class="n"&gt;ip_range_urls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://api.bgpview.io/asn/59930/prefixes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;https://api.bgpview.io/asn/62014/prefixes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="s1"&gt;&amp;#39;https://api.bgpview.io/asn/62041/prefixes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tg_ipset_redirect.sh&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;#! /bin/bash&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ipset create telegram hash:net -!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ip_range_urls&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ip_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loads&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;ip_range&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ip_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;data&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ipv4_prefixes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
            &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ipset add telegram {} -!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip_range&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;prefix&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

    &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;iptables -t nat -A PREROUTING -p tcp -m set --match-set telegram dst -j REDIRECT --to-ports 1080&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;iptables -t nat -A OUTPUT -p tcp -m set --match-set telegram dst -j REDIRECT --to-ports 1080&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;产生的bash脚本如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#! /bin/bash&lt;/span&gt;
ipset create telegram hash:net -!
ipset add telegram &lt;span class="m"&gt;91&lt;/span&gt;.108.12.0/22 -!
ipset add telegram &lt;span class="m"&gt;149&lt;/span&gt;.154.172.0/22 -!
ipset add telegram &lt;span class="m"&gt;91&lt;/span&gt;.108.16.0/22 -!
ipset add telegram &lt;span class="m"&gt;91&lt;/span&gt;.108.56.0/23 -!
ipset add telegram &lt;span class="m"&gt;149&lt;/span&gt;.154.168.0/22 -!
ipset add telegram &lt;span class="m"&gt;91&lt;/span&gt;.108.4.0/22 -!
ipset add telegram &lt;span class="m"&gt;91&lt;/span&gt;.108.8.0/22 -!
ipset add telegram &lt;span class="m"&gt;91&lt;/span&gt;.108.56.0/22 -!
ipset add telegram &lt;span class="m"&gt;149&lt;/span&gt;.154.160.0/20 -!
ipset add telegram &lt;span class="m"&gt;149&lt;/span&gt;.154.164.0/22 -!
iptables -t nat -A PREROUTING -p tcp -m &lt;span class="nb"&gt;set&lt;/span&gt; --match-set telegram dst -j REDIRECT --to-ports &lt;span class="m"&gt;1080&lt;/span&gt;
iptables -t nat -A OUTPUT -p tcp -m &lt;span class="nb"&gt;set&lt;/span&gt; --match-set telegram dst -j REDIRECT --to-ports &lt;span class="m"&gt;1080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这么一看，当初还写什么脚本，IP段也没几个啊，害得我一度以为脚本写错了，是不是漏了什么IP，结果上网站一查还真就这几个IP段。
Bash脚本应该都看得懂吧，就是把telegram的IP加入一个ipset中(当然，你得先安装ipset，一般默认都没有)，然后把符合tcp协议的、同时目的IP属于这个ipset内的流量，全部转发到ss-redir产生的1080透明代理端口上。&lt;/p&gt;
&lt;h2&gt;在国内VPS安装MTProxy&lt;/h2&gt;
&lt;p&gt;不知道为啥，写这篇文章的时候，用官方的MTProxy在本地搭的测试环境一直连不上，之前在国外VPS上搭都是OK的。这次干脆直接换成了纯python3版本的&lt;a href="https://github.com/alexbers/mtprotoproxy"&gt;mtprotoproxy&lt;/a&gt;，还省去了build过程。&lt;/p&gt;
&lt;p&gt;git clone下来后，改下端口设置就行了。config.py里的Users，其实就是个16位的随机secret，可以用以下命令产生：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;head -c 16 /dev/urandom | xxd -ps
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你还可以配置多个secret，这样就可以把secret当Users来管理了，虽然我目前还没发现这玩意有什么管理功能。&lt;/p&gt;
&lt;p&gt;对于python脚本的启动管理，我向来喜欢转个supervisor搞定，只需要写个配置文件就行了:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;command=/usr/bin/python3 /root/.services/mtprotoproxy/mtprotoproxy.py
startsecs=1
startretries=100
autorstart=true
autorestart=true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，我建议你可以先手工执行以下这个服务器命令，这样会自动echo出产生的MTProxy的地址，省的你自己再去一点点拼起来。&lt;/p&gt;
&lt;h2&gt;固化ipset和iptables规则&lt;/h2&gt;
&lt;p&gt;ipset和iptables默认重启后就会掉了，我们可以先把他们保存到文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipset save &amp;gt; /etc/ipset.conf
iptables-save  &amp;gt; /etc/iptables.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后在/etc/rc.local里(对应的是ubuntu/debian系统，centos自己想办法)，写入从文件还原ipset和iptables的命令就可以了：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;

ipset restore &amp;lt; /etc/ipset.conf
iptables-restore &amp;lt; /etc/iptables.conf

&lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;ubuntu18默认没有/etc/rc.local文件了，自己创建一个就行，记得chomod +x /etc/rc.local给它添加可执行属性。&lt;/p&gt;</content></entry><entry><title>ShadowsocksR MudbJSON版的单端口多用户配置</title><link href="posts/multiuser_on_single_port_for_SSR_mudbjson.html" rel="alternate"></link><published>2019-02-25T14:39:43+08:00</published><updated>2019-02-25T14:39:43+08:00</updated><author><name>毕勤</name></author><id>tag:None,2019-02-25:posts/multiuser_on_single_port_for_SSR_mudbjson.html</id><summary type="html">&lt;p&gt;网上最早的也最权威的关于SSR单端口多用户的配置是破娃酱写的，虽然文章已经被删了，但用&lt;a href="http://web.archive.org/web/20170727124018/https://breakwa11.blogspot.com/2017/01/shadowsocksr-mu.html"&gt;archive&lt;/a&gt;还是可以看到的，只是文章有些地方写的还不够细致，容易产生误解。最近自己刚好也在尝试这个配置，重新记录并说明一下，方便以后查看。&lt;/p&gt;</summary><content type="html">&lt;p&gt;网上最早的也最权威的关于SSR单端口多用户的配置是破娃酱写的，虽然文章已经被删了，但用&lt;a href="http://web.archive.org/web/20170727124018/https://breakwa11.blogspot.com/2017/01/shadowsocksr-mu.html"&gt;archive&lt;/a&gt;还是可以看到的，只是文章有些地方写的还不够细致，容易产生误解。最近自己刚好也在尝试这个配置，重新记录并说明一下，方便以后查看。&lt;/p&gt;
&lt;p&gt;首先明确一下，这里只讨论MudbJson版的单端口多用户配置，机场用的SSPanel不在此讨论范围。其实MudbJson是一个非常适合少数几个人一起搭建小机场的配置方式，在保证多用户特性的情况下没有多余的附加组件，可以给不同用户数设置限速和限流量等参数，即使有多个服务器节点存在，也只需要在各个服务期间同步一个json文件就可以了。&lt;/p&gt;
&lt;p&gt;单端口多用户的目的是什么？是集中服务器的端口使用，避免大量开放端口，一个服务器同时开放几百个TCP端口同时都还有不小的数据量，这不用分析都可以猜到是干啥的。而把端口隐藏到443，995这样的常用服务端口上并配合一定的混淆，相对会增加一点探测难度。&lt;/p&gt;
&lt;p&gt;先直接看配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[
{
&amp;quot;d&amp;quot;: 0,
&amp;quot;enable&amp;quot;: 1,
&amp;quot;method&amp;quot;: &amp;quot;none&amp;quot;,
&amp;quot;obfs&amp;quot;: &amp;quot;tls1.2_ticket_auth&amp;quot;,
&amp;quot;passwd&amp;quot;: &amp;quot;JKlzs)9j&amp;quot;,
&amp;quot;port&amp;quot;: 995,
&amp;quot;protocol&amp;quot;: &amp;quot;auth_chain_b&amp;quot;,
&amp;quot;protocol_param&amp;quot;: &amp;quot;#&amp;quot;,
&amp;quot;transfer_enable&amp;quot;: 9007199254740992,
&amp;quot;u&amp;quot;: 0,
&amp;quot;user&amp;quot;: &amp;quot;995&amp;quot;
},
{
&amp;quot;d&amp;quot;: 16668442,
&amp;quot;enable&amp;quot;: 1,
&amp;quot;method&amp;quot;: &amp;quot;none&amp;quot;,
&amp;quot;obfs&amp;quot;: &amp;quot;tls1.2_ticket_auth&amp;quot;,
&amp;quot;passwd&amp;quot;: &amp;quot;R=KA2VmQ&amp;quot;,
&amp;quot;port&amp;quot;: 100002,
&amp;quot;protocol&amp;quot;: &amp;quot;auth_chain_b&amp;quot;,
&amp;quot;transfer_enable&amp;quot;: 9007199254740992,
&amp;quot;u&amp;quot;: 673936,
&amp;quot;user&amp;quot;: &amp;quot;100002&amp;quot;
}
]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先建立一个默认的用户，为了方便，我们默认吧用户ID和用户端口写成一样的，这里就是995用户，这个用户最明显的特征，就是protocol param是“#”,这样的参数用于标识这是个默认用户，但这个用户是不可用的，因为protocol param只写个“#”是无效的。&lt;/p&gt;
&lt;p&gt;然后再新建一个用户，用户ID大于65535，同样的端口也大于65535，因为大于65535的端口都是不存在的，所以表示这是个单端口多用户账户，这个用户的加密混淆这些东西可以和默认用户一样也可以随便写，因为这些都是被忽略的。除了用户端口，密码之外，一切都使用默认用户的配置。&lt;/p&gt;
&lt;p&gt;所以，这里的100002用户，需要使用&lt;strong&gt;默认用户的端口、密码&lt;/strong&gt;、协议、混淆方式来连接SSR服务器，后面添加的其他用户也是一样，那么连密码都一样的话怎么区分不同的用户呢？那就需要使用protocol param了，protocol param就是这个用户的ID和自己密码的组合，即 100002:R=KA2VmQ。&lt;/p&gt;
&lt;p&gt;也就是说，对这些后面新建的非默认用户来说，连接时使用的密码就是默认用户的密码，而配置文件中写的自己的密码，是用来和自己的ID组合成protocol param用的。&lt;/p&gt;
&lt;p&gt;使用auth_chain_*协议的话，即使使用相同的密码，但只要protocol param不同，不同用户间的数据也是不可互相解密的。&lt;/p&gt;</content></entry><entry><title>使用rclone自动备份Google Photos到本地硬盘</title><link href="posts/use_rclone_to_backup_google_photos.html" rel="alternate"></link><published>2018-12-19T15:55:00+08:00</published><updated>2018-12-19T15:55:00+08:00</updated><author><name>毕勤</name></author><id>tag:None,2018-12-19:posts/use_rclone_to_backup_google_photos.html</id><summary type="html">&lt;p&gt;首先墙裂推荐一下Google Photos，基本上各个平台都能用，不需要原始画质的话不用考虑容量问题，可以随心所欲的备份所有照片，更好的是它的自动影集生成功能和从视频共裁剪gif图片的功能，经常能带来很多意想不到的惊喜。&lt;/p&gt;</summary><content type="html">&lt;p&gt;首先墙裂推荐一下Google Photos，基本上各个平台都能用，不需要原始画质的话不用考虑容量问题，可以随心所欲的备份所有照片，更好的是它的自动影集生成功能和从视频共裁剪gif图片的功能，经常能带来很多意想不到的惊喜。当然它也有一个问题：需要翻墙。&lt;/p&gt;
&lt;p&gt;我倒不是担心哪天墙高到翻不出去的地步，但毕竟所有照片都在上面，觉得还是有必要在本地存一个备份以便随时查看，这样Google Photos就成了一个集散中心，本地成了最终的备份仓库。我有一台装了ubuntu server的deskmini，刚开始的想法是看看有没有Google Photos的linux客户端，后来发现更简单的方法是使用&lt;a href="https://rclone.org/"&gt;rclone&lt;/a&gt;这个全平台制霸的同步工具。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;安装过程非常简单，一条命令就搞定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl https://rclone.org/install.sh | sudo bash
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;配置GoogleDrive账号&lt;/h2&gt;
&lt;p&gt;基本的配置过程可以参考&lt;a href="https://rclone.org/drive/"&gt;这里&lt;/a&gt;，这里只说一下要点：
&lt;em&gt; client id什么的其实都不用管，直接回车就可以了，最终是通过web auth来实现认证的，如果已经登录了Google 账号，全程不需要输入密码。
&lt;/em&gt; 如果你是用过ssh链接ubuntu server配置，不要选择auto config模式，因为机器上并没有浏览器让你进行web auth,让rclone生成一个web地址，你自己打开这个地址后获得一个授权码，然后粘贴回去。
&lt;em&gt; name那项随便填，但要记住，这就是以后你google drive根目录的别称了。
&lt;/em&gt; 介于我只需要同步到本地，权限选择read only就可以了，以免误操作删除了文件夹。
* 默认情况下Google Photos目录并不出现在Google Drive中，需要访问google drive的web设置，勾选“Create a Google Photos folder”这项，如果有必要，建议把出现后的Google Photo目录名称改成无空格的英文路径，否则中文路径带个空格挺烦人的。&lt;/p&gt;
&lt;h2&gt;同步到本地&lt;/h2&gt;
&lt;p&gt;一条命令就行了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rclone copy gdrive:GooglePhotos /SafeHub/GooglePhotos
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;gdrive就是刚才建立的Googledrive的账号名称，也就是刚才说的以后都是根目录别称的那个，后面的/SafeHub是我自己本机上的一个RAID1磁盘，根据你的情况选择本地路径即可。&lt;/p&gt;
&lt;h2&gt;自动执行&lt;/h2&gt;
&lt;p&gt;先找出配置文件的路径：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rclone config file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后运行crontab -e来添加一个cronjob，例如我希望他每天2：30分备份一次(已经下载的会自动跳过),就添加这样的一个cron job：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;30 2 * * * /usr/bin/rclone --config /root/.config/rclone/rclone.conf copy gdrive:GooglePhotos /SafeHub/GooglePhotos
&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>VPS的Netflix IP解锁服务自制版</title><link href="posts/setup_netflix_unblocker_for_vps.html" rel="alternate"></link><published>2018-12-01T23:55:00+08:00</published><updated>2018-12-01T23:55:00+08:00</updated><author><name>毕勤</name></author><id>tag:None,2018-12-01:posts/setup_netflix_unblocker_for_vps.html</id><summary type="html">&lt;p&gt;最近已经基本上把看片的平台转移到Netflix了，确实节省了很多下片找片的时间，而且，不考虑防火墙和代理的问题下，这好歹是正版的付费看片。鉴于中国的现状，看Netflix翻墙是必须的，而且还挑梯子，Netflix基本上把大厂的IP都给列入封锁列表了，指望用Google Cloud搭酸酸乳看Netflix是个比较遥远的梦想。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;需求的起源&lt;/h2&gt;
&lt;p&gt;最近已经基本上把看片的平台转移到Netflix了，确实节省了很多下片找片的时间，而且，不考虑防火墙和代理的问题下，这好歹是正版的付费看片。鉴于中国的现状，看Netflix翻墙是必须的，而且还挑梯子，Netflix基本上把大厂的IP都给列入封锁列表了，指望用Google Cloud搭酸酸乳看Netflix是个比较遥远的梦想。&lt;/p&gt;
&lt;p&gt;最近在某VPS服务商那里看到他们提供一个Netflix IP解锁服务，也就是说让那些本来不能播放Netflix的VPS，通过他们的服务可以播放指定区域的VPS。刚开始我脑子一抽还以为他们能把数据中心的IP变成家庭宽带的IP来骗过Netflix，后来闻了一下需要提供VPS的root密码来让他们设置，我一看这不就是个代理服务吗？&lt;/p&gt;
&lt;p&gt;其实这个也挺好的，因为在墙外的VPS之间，也就是数据中心之前其实速度还是很快的，基本上不用担心带宽不足延迟太大或者速度不稳定这些问题，即使经过一次转发，也不太影响使用体验。&lt;/p&gt;
&lt;h2&gt;否定的第一套方案&lt;/h2&gt;
&lt;p&gt;最开始的方案基本上就是靠着Google搜Netflix Proxy找到的，简单的说就是在可以看Netflix的VPS A上搭一个TCP反代，在VPS B上用dnsmasq之类的工具劫持DNS解析，把Netflix的相关域名都解析到VPS A上，这样VPS B就可以借用A的反代来访问Netflix了。
废话不多少直接上代码，VPS A上安装sniproxy，配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;user nobody
resolver {
    nameserver 8.8.8.8
    mode ipv4_only
}

listen 0.0.0.0:443 {
proto tls
table https_hosts
access_log {
  filename /var/log/https_access.log
  priority notice
 }
}

table https_hosts {
    (.*.|)netflix.com$ *
    (.*.|)netflix.net$ *
    (.*.|)nflxext.com$ *
    (.*.|)nflxso.net$ *
    (.*.|)nflximg.net$ *
    (.*.|)nflxvideo.net$ *
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;VPS B上安装dnsmasq，配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;no-resolv
no-poll
server=1.1.1.1
address=/netflix.com/18.215.191.191
address=/nflxext.com/18.215.191.191
address=/nflximg.net/18.215.191.191
address=/nflxext.com/18.215.191.191
address=/nflxso.net/18.215.191.191
address=/nflxvideo.net/18.215.191.191
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方案之所以被否定，是因为本质上依赖DNS劫持。你可以劫持VPS B本身的DNS解析，但你在VPS B上搭建梯子后，你并没有办法保证劫持连上这个梯子的用户的DNS。大部分用户使用ssr-redir提供的透明代理，基于域名转发，这样是可以的，但还是有部分用户不适用远端的DNS解析而使用本地的解析，这样就无法成功劫持了。所以对这部分用户来说，流量还是会经过VPS B的代理，但会不被劫持的访问原始的Netflix服务器，最终导致播放失败。&lt;/p&gt;
&lt;h2&gt;新方案&lt;/h2&gt;
&lt;p&gt;其实我把问题想得太复杂了，这不就是普通的透明代理转发吗？shadowsocks(R)就可以实现啊，只不过两台墙外的VPS用加密代理实在是浪费CPU资源，普通的代理就足够了。所以我决定在VPS A用Tinyproxy架设https代理，然后在VPS B用redsocks转成透明代理然后转发。&lt;/p&gt;
&lt;h3&gt;架设Tinyproxy Https代理&lt;/h3&gt;
&lt;p&gt;其实很简单，直接apt-get install tinyproxy就可以了。设置上我也几乎没有修改，仅仅是添加了一个Allow语句，给VPS B的IP放行，否则是无法使用的。而且这样默认也屏蔽了其他IP的访问，避免了变成冤大头。
最后的配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;User tinyproxy
Group tinyproxy
Port 8888
Timeout 600
DefaultErrorFile &amp;quot;/usr/share/tinyproxy/default.html&amp;quot;
StatFile &amp;quot;/usr/share/tinyproxy/stats.html&amp;quot;
Logfile &amp;quot;/var/log/tinyproxy/tinyproxy.log&amp;quot;
LogLevel Info
PidFile &amp;quot;/run/tinyproxy/tinyproxy.pid&amp;quot;
MaxClients 100
MinSpareServers 5
MaxSpareServers 20
StartServers 10
MaxRequestsPerChild 0
Allow 127.0.0.1
Allow YOUR_VPS_B_IP
ViaProxyName &amp;quot;tinyproxy&amp;quot;
ConnectPort 443
ConnectPort 563
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;架设Redsocks代理&lt;/h3&gt;
&lt;p&gt;也是直接apt-get install redsocks，配置中只需要设置好https代理的IP和端口就行，记得https代理的类型是填http-connect。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;connection&lt;/span&gt; &lt;span class="kc"&gt;progress&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="kc"&gt;on&lt;/span&gt; &lt;span class="n"&gt;SIGUSR1&lt;/span&gt;
    &lt;span class="n"&gt;log_debug&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;start&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="kc"&gt;end&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;
    &lt;span class="n"&gt;log_info&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c"&gt;/* possible `log&amp;#39; values are:&lt;/span&gt;
&lt;span class="c"&gt;     *   stderr&lt;/span&gt;
&lt;span class="c"&gt;     *   &amp;quot;file:/path/to/file&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;     *   syslog:FACILITY  facility is any of &amp;quot;daemon&amp;quot;, &amp;quot;local0&amp;quot;...&amp;quot;local7&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;     */&lt;/span&gt;
    &lt;span class="err"&gt;log&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;syslog&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;daemon&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;;&lt;/span&gt;

&lt;span class="s2"&gt;    // detach from console&lt;/span&gt;
&lt;span class="s2"&gt;    daemon = on;&lt;/span&gt;

&lt;span class="s2"&gt;    /* Change uid, gid and root directory, these options require root&lt;/span&gt;
&lt;span class="s2"&gt;     * privilegies on startup.&lt;/span&gt;
&lt;span class="s2"&gt;     * Note, your chroot may requre /etc/localtime if you write log to syslog.&lt;/span&gt;
&lt;span class="s2"&gt;     * Log is opened before chroot &amp;amp; uid changing.&lt;/span&gt;
&lt;span class="s2"&gt;     */&lt;/span&gt;
&lt;span class="s2"&gt;    user = redsocks;&lt;/span&gt;
&lt;span class="s2"&gt;    group = redsocks;&lt;/span&gt;
&lt;span class="s2"&gt;    // chroot = &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;chroot&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;;&lt;/span&gt;

&lt;span class="s2"&gt;    /* possible `redirector&amp;#39; values are:&lt;/span&gt;
&lt;span class="s2"&gt;     *   iptables   - for Linux&lt;/span&gt;
&lt;span class="s2"&gt;     *   ipf        - for FreeBSD&lt;/span&gt;
&lt;span class="s2"&gt;     *   pf         - for OpenBSD&lt;/span&gt;
&lt;span class="s2"&gt;     *   generic    - some generic redirector that MAY work&lt;/span&gt;
&lt;span class="s2"&gt;     */&lt;/span&gt;
&lt;span class="s2"&gt;    redirector = iptables;&lt;/span&gt;
&lt;span class="s2"&gt;}&lt;/span&gt;

&lt;span class="s2"&gt;redsocks {&lt;/span&gt;
&lt;span class="s2"&gt;    /* `local_ip&amp;#39; defaults to 127.0.0.1 for security reasons,&lt;/span&gt;
&lt;span class="s2"&gt;     * use 0.0.0.0 if you want to listen on every interface.&lt;/span&gt;
&lt;span class="s2"&gt;     * `local_*&amp;#39; are used as port to redirect to.&lt;/span&gt;
&lt;span class="s2"&gt;     */&lt;/span&gt;
&lt;span class="s2"&gt;    local_ip = 127.0.0.1;&lt;/span&gt;
&lt;span class="s2"&gt;    local_port = 12345;&lt;/span&gt;

&lt;span class="s2"&gt;    // `ip&amp;#39; and `port&amp;#39; are IP and tcp-port of proxy-server&lt;/span&gt;
&lt;span class="s2"&gt;    // You can also use hostname instead of IP, only one (random)&lt;/span&gt;
&lt;span class="s2"&gt;    // address of multihomed host will be used.&lt;/span&gt;
&lt;span class="s2"&gt;    ip = YOUR_VPS_A_IP; &lt;/span&gt;
&lt;span class="s2"&gt;    port = 8888;&lt;/span&gt;


&lt;span class="s2"&gt;    // known types: socks4, socks5, http-connect, http-relay&lt;/span&gt;
&lt;span class="s2"&gt;    type = http-connect;&lt;/span&gt;

&lt;span class="s2"&gt;    // login = &amp;quot;&lt;/span&gt;&lt;span class="n"&gt;foobar&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;;&lt;/span&gt;
&lt;span class="s2"&gt;    // password = &amp;quot;&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后配置iptables，先建立一个REDSOCKS链:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -t nat -N REDSOCKS
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里有两套思路进行转发，一套是找出Netflix所有的IP地址，然后添加到REDSOCKS链，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -t nat -A OUTPUT -d 198.38.0.0/16 -j REDSOCKS
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但问题是Netflix使用了akamai的CDN服务器，IP地址范围是在太大了，我已经把Netflix整个&lt;a href="https://ipinfo.io/AS2906"&gt;AS的地址&lt;/a&gt;都添加了也还是会提示在使用proxy。&lt;/p&gt;
&lt;p&gt;干脆暴力点，直接把所有https流量都添加进去:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDSOCKS
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，转发到redsocks的透明代理端口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后记得用iptables-persistent之类的工具保存一下iptables规则，这样不论是从VPS B本机访问，还是透过VPS B上的代理，最后Netflix的HTTPS流量都会通过VPS A访问，而Netflix是全Https的，所以http部分我们不需要关心。&lt;/p&gt;
&lt;h2&gt;更小的IP范围&lt;/h2&gt;
&lt;p&gt;全部转发可能还是太暴力了，简单一点的做法是转发Netflix所有的IP和AWS所有的IP(因为当前Netflix有很多服务是架设在AWS上的)。&lt;/p&gt;
&lt;p&gt;Netflix的IP可以在&lt;a href="https://ipinfo.io/AS2906"&gt;这里&lt;/a&gt;查到，而AWS的IP可以在&lt;a href="https://ipinfo.io/AS2906"&gt;这里&lt;/a&gt;看到，然后把这些IP范围分别添加到两个IPSET中，我把它们分别命名为aws和netflix。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipset create aws hash:net
ipset create netflix hash:net
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;怎么转成命令我就懒得写了，&lt;a href="https://www.lifetyper.com/files/ipset.sh"&gt;这里&lt;/a&gt;有现成的脚本。
Update:生成bash命令的Python脚本在&lt;a href="https://gist.github.com/lifetyper/347cf7c4dbadee91e80670acb064b670"&gt;这里&lt;/a&gt;，自己去看吧。&lt;/p&gt;
&lt;p&gt;然后，把这两个IPSET里IP的443端口目标流量全部转发到REDSOCKS的透明代理上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -t nat -A PREROUTING -p tcp --dport 443 -m set --match-set aws dst -j REDIRECT --to-ports 12345
iptables -t nat -A PREROUTING -p tcp --dport 443 -m set --match-set netflix dst -j REDIRECT --to-ports 12345
iptables -t nat -A OUTPUT -p tcp --dport 443 -m set --match-set aws dst -j REDIRECT --to-ports 12345
iptables -t nat -A OUTPUT -p tcp --dport 443 -m set --match-set netflix dst -j REDIRECT --to-ports 12345
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可能的问题：
&lt;em&gt; 你的代理服务器本身就是AWS服务器，这个就比较尴尬了，自己添加一个排除规则吧，其实AWS的服务器就算能看Netflix也是暂时的，早晚被封。
&lt;/em&gt; 重启后ipset丢失，这是个问题，我目前也不知道有什么更优雅的方式来解决，简单点可以在启动项里重写ipset。&lt;/p&gt;
&lt;h2&gt;保存这些规则&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipset save &amp;gt; /etc/ipset.conf
iptables-save  &amp;gt; /etc/iptables.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后在/etc/rc.local里写入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipset restore &amp;lt; /etc/ipset.conf
iptables-restore &amp;lt; /etc/iptables.conf
&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>How to setup your own dero web wallet</title><link href="posts/setup_dero_web_wallet.html" rel="alternate"></link><published>2018-11-26T10:55:00+08:00</published><updated>2018-11-26T10:55:00+08:00</updated><author><name>lifetyper</name></author><id>tag:None,2018-11-26:posts/setup_dero_web_wallet.html</id><summary type="html">&lt;p&gt;Dero nightly build has already support a very useful new funtion:Web Wallet.It's archived by using golang web assembly build,totally run in your browser.As mentioned by dero dev team, dero gui wallet will be abandoned, all resouce will focused on web wallet.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;The future for dero wallet&lt;/h1&gt;
&lt;p&gt;Dero nightly build has already support a very useful new funtion:Web Wallet.It's archived by using golang web assembly build,totally run in your browser.As mentioned by dero dev team, dero gui wallet will be abandoned, all resouce will focused on web wallet.&lt;/p&gt;
&lt;p&gt;Besides the official derowallet.io, you may want to setup your own web wallet, host on a server for public use or just run it locally.Here is  the step for set up your own dero web wallet.&lt;/p&gt;
&lt;h2&gt;Compile new version of dero daemon to support web wallet&lt;/h2&gt;
&lt;p&gt;To support web assembly funtion, you need to use minimum Golang version 1.11.1 for this  build, old version will not work.&lt;/p&gt;
&lt;p&gt;git clone the code from dero offcial git repo &lt;a href="https://git.dero.io/DeroProject/derosuite_webwallet"&gt;https://git.dero.io/DeroProject/derosuite_webwallet&lt;/a&gt;. You'd better move the code to your Gopath source folder, the source path for me is &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~/go/src/github.com/deroproject/derosuite
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then build it with command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;go install github.com/deroproject/derosuite/cmd/...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You shall find binary file under $GOPATH/bin folder.&lt;/p&gt;
&lt;p&gt;If you want to deploy your web wallet to a linux web server but your building system is others, you can specify the GOOS and GOARCH for this build&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;GOOS=linux GOARH=amd64 go install github.com/deroproject/derosuite/cmd/...
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Compile web assembly file for web wallet&lt;/h2&gt;
&lt;p&gt;All core wallet function is implemented in the web wallet web assembly file, you can build it with command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd ~/go/src/github.com/deroproject/derosuite/
GOOS=js GOARCH=wasm go build -o wallet.wasm cmd/webwallet/main.go
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You will find a file named wallet.wasm where you excute this command.&lt;/p&gt;
&lt;h2&gt;Get the web root for web wallet&lt;/h2&gt;
&lt;p&gt;Simple git clone the web root from Get from &lt;a href="https://git.dero.io/DeroProject/webroot"&gt;https://git.dero.io/DeroProject/webroot&lt;/a&gt;, then move the wallet.wasm file we just compiled into the webroot/static/ folder.&lt;/p&gt;
&lt;h2&gt;Place the webroot folder to correct place&lt;/h2&gt;
&lt;p&gt;You need to place the webroot folder to the folder &lt;strong&gt;where you run the dero daemon&lt;/strong&gt;,if we place it under ~/dero/ folder,  then we should start dero daemon from that folder.&lt;/p&gt;
&lt;h2&gt;Use the web wallet&lt;/h2&gt;
&lt;p&gt;After start the dero daemon from correct folder, you can visit http://127.0.0.1:20206/ to access the web wallet.&lt;/p&gt;
&lt;h2&gt;Host it to a public web server&lt;/h2&gt;
&lt;p&gt;In fact, host it to a public web server is almost the same as run a remote node, please read &lt;a href="https://lifetyper.com/posts/run_remote_node_for_dero_wallet.html"&gt;my previous article&lt;/a&gt; for the detailed guide.&lt;/p&gt;
&lt;h2&gt;My Dero Web Wallet&lt;/h2&gt;
&lt;p&gt;So, here is my public &lt;a href="https://derowallet.com/"&gt;dero web wallet&lt;/a&gt; you can use for free.No private data will be send to my server, since web wallet server works just like a remote node.&lt;/p&gt;</content></entry><entry><title>How to run a remote node for DERO wallet</title><link href="posts/run_remote_node_for_dero_wallet.html" rel="alternate"></link><published>2018-10-18T16:55:00+08:00</published><updated>2018-10-18T16:55:00+08:00</updated><author><name>lifetyper</name></author><id>tag:None,2018-10-18:posts/run_remote_node_for_dero_wallet.html</id><summary type="html">&lt;p&gt;One of the dero wallet's greatest feature is remote node function,which allows you to sync and use your DERO wallet without sync the whole blockchain.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Why do you need a remote node?&lt;/h2&gt;
&lt;p&gt;One of the &lt;a href="https://dero.io"&gt;dero&lt;/a&gt; wallet's greatest feature is remote node function,which allows you to sync and use your DERO wallet without sync the whole blockchain.Currently there is only one public node is run by dero Official(https://rwallet.dero.live:443).&lt;/p&gt;
&lt;p&gt;But a centralized server can crash or the network latency may too large for you due to different network condition, or even worse,you don't trust anyone else except yourself, you might want to run your own remote node for your wallet.&lt;/p&gt;
&lt;h2&gt;What do you need for a remote node&lt;/h2&gt;
&lt;p&gt;Here below is what you will need for running a remote node:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A VPS with public IPV4 address, running ubuntu or debian &lt;/li&gt;
&lt;li&gt;A domain for SSL certificate&lt;/li&gt;
&lt;li&gt;Done&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Then you can create your remote node following below step.&lt;/p&gt;
&lt;h2&gt;Setup your domain&lt;/h2&gt;
&lt;p&gt;This step is simple, just point your domain to your VPS's IP address,blabla...If any trouble with this part, ask your domain registar for help.&lt;/p&gt;
&lt;h2&gt;Install Nginx&lt;/h2&gt;
&lt;p&gt;Nginx is a famous http server which can also works a web proxy, here we use nginx to proxy dero daemon's default rpc service from port 127.0.0.1:20206 to 0.0.0.0:443(port for https web) and expose to public.
Install nginx is easy on ubuntu, install with root account is ok, but don't run it under root account.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get update
apt-get install nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Fetch SSL certificate for your domain&lt;/h2&gt;
&lt;p&gt;We have let's encrypt for free SSL certificate, to obtain SSL certificate easyliy we shall install &lt;a href="https://certbot.eff.org/"&gt;certbot&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get update
apt-get install software-properties-common
add-apt-repository ppa:certbot/certbot
apt-get update
apt-get install python-certbot-nginx 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After installation, run below command to get the ssl certificate&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;certbot certonly
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Just follow the instruction and enter needed info, and when it comes to this step:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;How would you like to authenticate with the ACME CA?
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1: Nginx Web Server plugin - Alpha (nginx)
2: Spin up a temporary webserver (standalone)
3: Place files in webroot directory (webroot)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Just type "1" to use nginx web plugin for domain verify.
After certificate done, take derowallet.com for example, you shall see below message telling you where is your certification and chain stored.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- Congratulations! Your certificate and chain have been saved at:
   /etc/letsencrypt/live/derowallet.com/fullchain.pem
   Your key file has been saved at:
   /etc/letsencrypt/live/derowallet.com/privkey.pem
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note down these two paths, we will use them later.&lt;/p&gt;
&lt;h2&gt;Setup Nginx as DERO rpc service proxy&lt;/h2&gt;
&lt;p&gt;Still take derowallet.com for example, let's create a config file for this proxy in "/etc/nginx/conf.d" and edit it with VIM:
&lt;code&gt;touch rwallet.conf
vi rwallet.conf&lt;/code&gt;
Then paste below content in rwallet.conf:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;listen&lt;/span&gt;          &lt;span class="err"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;server_name&lt;/span&gt;     &lt;span class="err"&gt;derowallet.com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;rewrite&lt;/span&gt; &lt;span class="err"&gt;^/(.*)&lt;/span&gt;  &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;derowallet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;permanent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;listen&lt;/span&gt;          &lt;span class="err"&gt;443&lt;/span&gt; &lt;span class="err"&gt;ssl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;server_name&lt;/span&gt;     &lt;span class="err"&gt;derowallet.com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;access_log&lt;/span&gt;      &lt;span class="err"&gt;/var/log/nginx/rwalelt_access.log&lt;/span&gt; &lt;span class="err"&gt;combined&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;error_log&lt;/span&gt;       &lt;span class="err"&gt;/var/log/nginx/rwallet_erro.log&lt;/span&gt; &lt;span class="err"&gt;error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="err"&gt;ssl_certificate&lt;/span&gt; &lt;span class="err"&gt;/etc/letsencrypt/live/derowallet.com/fullchain.pem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;ssl_certificate_key&lt;/span&gt; &lt;span class="err"&gt;/etc/letsencrypt/live/derowallet.com/privkey.pem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="err"&gt;location&lt;/span&gt; &lt;span class="err"&gt;/&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;proxy_pass&lt;/span&gt;         &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;20206&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;proxy_redirect&lt;/span&gt;     &lt;span class="err"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="err"&gt;proxy_set_header&lt;/span&gt;   &lt;span class="err"&gt;Host&lt;/span&gt;              &lt;span class="err"&gt;$http_host&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;proxy_set_header&lt;/span&gt;   &lt;span class="err"&gt;X-Real-IP&lt;/span&gt;         &lt;span class="err"&gt;$remote_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;proxy_set_header&lt;/span&gt;   &lt;span class="err"&gt;X-Forwarded-For&lt;/span&gt;   &lt;span class="err"&gt;$proxy_add_x_forwarded_for&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Remember to replace derowallet.com with your own domain, and set the correct path for your ssl certificate and chain, then restart nginx service:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/etc/init.d/nginx restart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now let's visit &lt;a href="https://derowallet.com"&gt;https://derowallet.com&lt;/a&gt; you should see a "502 bad gateway" error.This means nginx is working as expected, the only problem is you haven't run dero daemon at port 20206 yet.&lt;/p&gt;
&lt;h2&gt;Run dero daemon&lt;/h2&gt;
&lt;h3&gt;install dero daemon&lt;/h3&gt;
&lt;p&gt;First let's go to &lt;a href="https://github.com/deroproject/derosuite/releases/latest"&gt;dero official github&lt;/a&gt; to download the latest binaries for dero daemon.
Since we're using ubuntu 16.04 64bit as our VPS os here, we should download linux_amd64 version, extract the tarball and copy the binaries to "/usr/local/bin" folder to make it global available.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget https://github.com/deroproject/derosuite/releases/download/v2.1.5/dero_linux_amd64_2.1.5-0.alpha.atlantis.10102018.tar.gz
tar xf dero_linux_amd64_2.1.5-0.alpha.atlantis.10102018.tar.gz
cp dero_linux_amd64/* /usr/local/bin
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Create data folder for dero&lt;/h3&gt;
&lt;p&gt;Let's make a folder for dero to store the chain data:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir /root/.dero
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;using name like ".dero" with a dot in the front will make the folder default hidden for 'ls' command and avoid stupid "rm -rf" command delete it.&lt;/p&gt;
&lt;h3&gt;Run dero daemon&lt;/h3&gt;
&lt;p&gt;Since we create a folder(/root/.dero) for blockchain data store, we should use this folder as data-dir every time we run dero daemon.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;derod-linux-amd64 --data-dir=/root/.dero
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After this command you should see dero command line daemon start and a folder named "mainnet" created under "/root/.dero" folder.
This time when you visit https://derowallet.com, browser should return a "Hello world!" message, which means everything is done.&lt;/p&gt;
&lt;h3&gt;Make dero daemon autostart and run in background&lt;/h3&gt;
&lt;p&gt;Dero daemon is an interactive command line program, the most easy way to run it in background is using screen command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;screen -d -m derod-linux-amd64 --data-dir=/root/.dero
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now a new sub-shell has been created and dero daemon running in it, if you want to check the staus of this sub-shell, just type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;screen -r
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;if there're more than one sub-shell running on your server, you might need to use &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;screen -ls
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to list all running sub-shell and determine which one to enter.
if you want to leave the sub-shell, don't use ctrl+c which will end the daemon, use key "ctrl+a+d" and you shall return to main shell.&lt;/p&gt;
&lt;p&gt;To make the daemon auto start when we restart the server, place the command we run daemon in file "/etc/rc.local", edit this file so finally it may looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# rc.local
#
# This script is executed at the end of each multiuser runlevel.
# Make sure that the script will &amp;quot;exit 0&amp;quot; on success or any other
# value on error.
#
# In order to enable or disable this script just change the execution
# bits.
#
# By default this script does nothing.

/usr/bin/screen -d -m /usr/local/bin/derod-linux-amd64 --data-dir=/root/.dero

exit 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that this time we shall use full path for both screen and dero daemon.Restart the server and check https://derowallet.com to see if it works.&lt;/p&gt;
&lt;h2&gt;Using remote node&lt;/h2&gt;
&lt;p&gt;Currently dero GUI wallet doesn't support customized remote node, but we can use it for command line wallet, by using option --data-dir.&lt;/p&gt;
&lt;p&gt;Full command to use the remote node we just set up under mac os is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dero-wallet-cli-darwin-amd64 --daemon-address=https://derowallet.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If your node is full synced, your wallet should be ready for use now.&lt;/p&gt;</content></entry><entry><title>迁移到GithubPages后的域名设置问题</title><link href="posts/blog_moved_to_github_pages_and_domain_config.html" rel="alternate"></link><published>2018-07-22T16:55:00+08:00</published><updated>2018-07-22T16:55:00+08:00</updated><author><name>毕勤</name></author><id>tag:None,2018-07-22:posts/blog_moved_to_github_pages_and_domain_config.html</id><summary type="html">&lt;p&gt;基本上我一年也写不了一篇文章，服务器主要是拿来翻墙的，碰上服务器速度变慢了就得迁移一次，虽然已经是基于pelican的静态网站，但nginx还是得重新配置一次。。。&lt;/p&gt;</summary><content type="html">&lt;p&gt;基本上我一年也写不了一篇文章，服务器主要是拿来翻墙的，碰上服务器速度变慢了就得迁移一次，虽然已经是基于pelican的静态网站，但nginx还是得重新配置一次。&lt;/p&gt;
&lt;p&gt;刚好发现github pages已经对custom domain开放https功能了，这样基本上也就够了。静态blog基本上迁移没什么好废话的，就是这个custom domain的设置有点麻烦。&lt;/p&gt;
&lt;p&gt;其实如果我只需要绑定lifetyper.com的话也没什么问题，但我一直都是lifetyper.com和www.lifetyper.com同时绑定的，githubpages上设置的域名是根域名，如果直接把两个域名的A记录都解析到github的地址，结果是访问www子域名的时候会爆一个https证书错误，因为证书是为根域名颁发的，子域名并不能直接用这个证书。&lt;/p&gt;
&lt;p&gt;找了一下发现这个问题其实用cloudflare的DNS很好解决。首先要设置根域名的A记录到Github，让lifetyper.com正常访问，然后给www子域名设置一个page rules.&lt;/p&gt;
&lt;p&gt;例如我希望把有所www.lifetyper.com的访问都转移到lifetyper.com，同时保持链接不掉，可以这样设置：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;url description:*www.lifetyper.com/*&lt;/p&gt;
&lt;p&gt;forwarding url:https://lifetyper.com/$2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里$2表示替换为第二个通配符*的值，同理，可以用美元符+数字匹配多个通配符。&lt;/p&gt;
&lt;p&gt;但这样的设置是不够的，因为www.lifetyper.com并没有任何DNS记录，cloudflare不能接管一个没有任何记录的域名，所以需要给www.lifetyper.com设置一条CNAME记录，值为@，同时保证这条记录是DNS&amp;amp;HTTP Proxied By Cloudflare的橙色。&lt;/p&gt;
&lt;p&gt;都设置成功后，稍等一段时间就可以生效了，这样所有的访问都被导向根域名了。&lt;/p&gt;</content></entry><entry><title>制作你自己的终极X86软路由</title><link href="posts/build_your_own_x86_router.html" rel="alternate"></link><published>2017-04-02T14:59:49+08:00</published><updated>2017-04-02T14:59:49+08:00</updated><author><name>毕勤</name></author><id>tag:None,2017-04-02:posts/build_your_own_x86_router.html</id><summary type="html">&lt;p&gt;自从当年被&lt;a href="https://code.google.com/archive/p/autoddvpn/"&gt;AutoddVPN&lt;/a&gt;项目带入路由器翻墙的坑，断断续续买过的路由器有差不多二十来个了。从最低端的400Mhz单核的Atheros芯片到双核1G的高端路由，从小到只有火柴盒大小的WT-32020到比砖头还大的R7000，基本都玩了个遍,但也都很无聊，因为最终都是刷openwrt或者dd-wrt，后者的可玩性其实还更差...&lt;/p&gt;</summary><content type="html">&lt;h2&gt;原因&lt;/h2&gt;
&lt;p&gt;自从当年被&lt;a href="https://code.google.com/archive/p/autoddvpn/"&gt;AutoddVPN&lt;/a&gt;项目带入路由器翻墙的坑，断断续续买过的路由器有差不多二十来个了。从最低端的400Mhz单核的Atheros芯片到双核1G的高端路由，从小到只有火柴盒大小的WT-32020到比砖头还大的R7000，基本都玩了个遍，但也都很无聊，因为最终都是刷openwrt或者dd-wrt，后者的可玩性其实还更差。&lt;/p&gt;
&lt;p&gt;直到年初入了EdgerouterX，才发现路由只做路由，无线交给AP，配合上linux系统才是真正的路由器王道。各司其职可以充分发挥各个环节的顶级性能，越接近原生linux的系统也越容易解决各类软件的安装问题，需要的软件包甚至可以直接在路由器上编译和部署。&lt;/p&gt;
&lt;p&gt;虽然基于ASIC芯片的路由在效率上更高，可以用更低的主频实现百兆甚至千兆的转发，但那是在路由主控CPU普遍主频只有300~400Mhz的时代的必需产物。当Intel把双核、四核的x86功率做到个位数以后，直接用高性能的x86搭建路由已经绝对是性能溢出的选择。&lt;/p&gt;
&lt;p&gt;从性价比上说，现在的高端路由普遍价格在1000元以上，部分甚至达到了2000~3000元的范围，当路由器价格达到这个范围的时候我就很难理解为什么还要去买这种一体化的高端路由了。一台X86小主机的价格一般不超过1000元，加1000元可以买一个顶级的ubnt的AP，2000元就可以给你带了最好的组合了，为什么还要买这种现货路由?&lt;/p&gt;
&lt;h2&gt;硬件部分&lt;/h2&gt;
&lt;h3&gt;主机的选择&lt;/h3&gt;
&lt;p&gt;感谢万能的淘宝，我在上面找到了一款有4个千兆以太网和一个RF45接口形式的RS232串口的J1900 CPU的小主机，店铺本身对这货的定义就是软路由主机。这个完全满足我的需求：&lt;/p&gt;
&lt;p&gt;&lt;img alt="J1900软路由" src="images/j1900_x86_router.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只要有线路由功能，无线功能可以交给专业的AP去处理。&lt;/li&gt;
&lt;li&gt;金属机身且体积小巧(15cmx13cmx3cm)，比很多外壳是塑料但里面全是空气的家庭路由还要小，可以轻松放进弱电箱，反正不涉及无线，不担心信号衰减。&lt;/li&gt;
&lt;li&gt;带有RS232接口便于调试，虽然SSH登录是很方便的，但一个IPtables命令错误后你就可以把自己挡在了路由器之外，这个时候你绝对不希望需要插上键盘和显示器才能调试。&lt;/li&gt;
&lt;li&gt;J1900也就是Bay Trail平台其实已经好几年了，这个平台的开发应用非常多也很成熟，linux的支持也很完美。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个小主机基本是完美的，除了一个地方:串口。这其实是个很尴尬的不满，因为机器上的串口是按照标准的EIA-561标注来接的，这看起来很合理，问题是这年头你一旦把串口做成RJ45的接口，10台机器有9台都是按照思科的那套标准来接的。以至于你现在去买USB Console调试线，只能买到思科标准的线，EIA-561标准的线只能自己做，如果用思科的Console线去调试，你会发下从主机出来的TX是好的，但RX永远收不到数据。&lt;/p&gt;
&lt;p&gt;于是我找了一根铜芯比较硬的网线，从实验室翻出一个DB9母头和塑料卡壳，自己做了一个RJ45转DB9母头的转接线，后面再接上普通的USB转DB9工头的USB串口线就可以了。其实RJ45转DB9那里，只需要把地线和TX、RX三根线接出来就可以了，因为大部分情况下我们并不会用到流控。&lt;/p&gt;
&lt;p&gt;&lt;img alt="RJ45转DB9母头" src="images/rj45_to_db9_female.png"&gt;&lt;/p&gt;
&lt;h3&gt;这里简单说一下RJ45转DB9该怎么接线:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首先明确我们不用流控，只需要找GND\TX\RX三根线。&lt;/li&gt;
&lt;li&gt;DB9上的GND是第5pin,第几Pin在哪里，DB9上都会有丝印告诉你的，很容易找。&lt;/li&gt;
&lt;li&gt;RJ45上找GND也很简单，用万用表的通断测试档，一端接RJ45的外壳，另一端一根根的试，导通的就是接地的GND。&lt;/li&gt;
&lt;li&gt;DB9上的RX/TX是2/3 Pin，这么多年以来我一直都对RX/TX的定义很困扰，因为针对不同的主从设备，RX和TX根本就是个混淆的概念，我的RX就是你的TX，你的RX就是我的TX，这里我们先不管，找出2/3Pin再说。&lt;/li&gt;
&lt;li&gt;RJ45上的TX/RX怎么找，如果有示波器当然就是一分钟的事，如果没有，只能找根电线，两根两根的短接，当然前面找到的GND可以先排除。标准的EI-561接法中RX/TX是相邻的，所以从水晶头那里可以很容易的找出哪些是相邻的，试几次就可以了。在Linux中开两个console,一个不停的往/dev/ttyS0写数据，一个cat /dev/ttyS0，当RX/TX短接时，你就可以在cat /dev/ttyS0的窗口看到自己写入的数据了。&lt;/li&gt;
&lt;li&gt;现在你知道了DB9和RJ45上的RX/TX是哪两组Pin了，但具体谁是TX谁是RX并不清楚，不重要，反正就两种组合，在焊死之前试一次不就行了，看起来很傻，但这样效率最高。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;软件部分&lt;/h2&gt;
&lt;h3&gt;系统的选择与安装&lt;/h3&gt;
&lt;p&gt;其实我刚开始的时候很想用&lt;a href="https://vyos.io"&gt;Vyos&lt;/a&gt;，这个系统其实就是EdgeRouter的EdgeOS的开源版本，基于Debian构建。而且新测试版的Vyos是基于Debian Jessie的，非常新，软件支持后期会很方便。&lt;/p&gt;
&lt;p&gt;但最后放弃的原因是，测试版确实不稳定啊，我连着试了两天的test build，安装后全部卡在了grub menu那里无法进入系统。old stable版本虽然安装没问题也能工作，但它是基于deian squeeze的，squeeze连LTS支持都结束了啊，实在不能忍。&lt;/p&gt;
&lt;p&gt;最后，我决定回到正常的linux发型版来，最终的选择是Debian Jessie amd64版本。我服务器本身的操作系统就是debian，一直用来编译shadowsocks server，非常的方便，其实ubuntu应该也差不多，只是个人喜好了。&lt;/p&gt;
&lt;p&gt;安装过程没太多好说的，只是最后选择组件的时候建议不要安装桌面环境，纯粹是浪费，除非你想要这个机器在做路由的同时也做HTPC用，问题是，这货只有VGA输出没有音频输出啊，做HTPC也不现实嘛。SSH-Server还是装上，毕竟网线比串口线方便。&lt;/p&gt;
&lt;p&gt;后期的很多操作我都建议你直接用root账号操作，因为user权限根本不够，整天用sudo不会比直接用root安全多少，反正你也不看任何warning。&lt;/p&gt;
&lt;h3&gt;开始Serial Console&lt;/h3&gt;
&lt;p&gt;为什么要开启Serial Console?因为我们有一个串口...&lt;/p&gt;
&lt;p&gt;这当然不是合理的理由，主要原因有两个，一个是我们后期的iptables操作可能会让ssh短期无法连接，另一个是serial console的层级更低，几乎等同于显示屏，可以便于我们调试一些底层boot信息。&lt;/p&gt;
&lt;p&gt;开启serial console其实很简单，只需要在grub配置中添加一个console到启动想就可以了，具体的方法是编辑/etc/default/grub文件，修改后的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;GRUB_DEFAULT=0
GRUB_TIMEOUT=1
GRUB_DISTRIBUTOR=`lsb_release -i -s 2&amp;gt; /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;&amp;quot;
GRUB_CMDLINE_LINUX=&amp;quot;console=tty0 console=ttyS0,115200&amp;quot;
GRUB_TERMINAL=serial
GRUB_SERIAL_COMMAND=&amp;quot;serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;修改GRUB_TIMEOUT是为了节省启动时间&lt;/li&gt;
&lt;li&gt;GRUB_CM_LINE_LINUX那行表示我们要同事开启两个console，一个是tty0(显示器)，另一个是ttyS0(串口)，串口速率是115200。&lt;/li&gt;
&lt;li&gt;GRUB_SERIAL_COMMAND是设定串口的参数，这里是最普通的8比特数据，1比特停止位，无校验。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改好之后运行以下命令重新生成grub.cfg文件，重启就可以看到serial console了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grub-mkconfig -o /boot/grub/grub.cfg
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在mac的terminal上，可以直接用以下命令连接到串口console&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;screen /dev/tty.usbXXXX 115200
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的XXXX会因为不同的设备而不同，是由你的USB转串口线决定的。&lt;/p&gt;
&lt;h3&gt;WAN与Bridge LAN&lt;/h3&gt;
&lt;p&gt;这里我把LAN1口作为WAN口来使用，我这里只考虑WAN口从上游的DHCP服务器自动获取IP的情况，如果需要WAN口有PPPOE拨号功能，请自行查找相关的文档。&lt;/p&gt;
&lt;p&gt;其实在高端的商用路有里，每个LAN都是有一个独立的网段的，这样可以给不同的区域和部门划分不同的访问区域。但在家用路由里，你绝对不希望手机连上WIFI后和访问不了在另一个网段里的NAS。所以我们要把LAN2,LAN3,LAN4并入一个网段，这个时候就需要在这三个接口之间做桥接，生成一个虚拟的接口。&lt;/p&gt;
&lt;p&gt;为了简单的实现这个功能，我们安装bridge-utils工具:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install bridge-utils
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后我们修改/etc/network/interfaces文件如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto lo
iface lo inet loopback
auto eth0
allow-hotplug eth0
iface eth0 inet dhcp
auto br0
allow-hotplug br0
iface br0 inet static
        address 192.168.88.1
        network 192.168.88.0
        netmask 255.255.255.0
        broadcast 192.168.88.255
        bridge-ports eth1 eth2 eth3
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;这里的192.168.88.1是路由器本身在LAN中的地址，也会是LAN中设备以后的网关。&lt;/li&gt;
&lt;li&gt;192.168.88.0是网络号，因为我们用了24位掩码，也就是255.255.255.0。&lt;/li&gt;
&lt;li&gt;192.168.88.255是广播地址，这是常识，主机位全1的地址是广播地址。&lt;/li&gt;
&lt;li&gt;我们把eth1 eth2 eth3，也就是LAN2,LAN3,LAN4 bridge成为一个新的接口br0，让这些端口处于一个网段中。&lt;/li&gt;
&lt;li&gt;auto表示速率自动协商，allow-hotplug见字面意思。&lt;/li&gt;
&lt;li&gt;lo是回环链路，系统默认不用修改。&lt;/li&gt;
&lt;li&gt;iface eth0 inet dhcp表示eth0也就是LAN1或者说我们的WAN的地址是通过DHCP获取的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;伟大的Dnsmasq&lt;/h3&gt;
&lt;p&gt;Dnsmasq不仅是路由器翻墙的重大功臣，也是构建路由器的重要法宝，因为一个小巧的dnsmasq就可以帮我们完成两项工作，DNS-Forwarder和DHCP Server。在作为路由器来用时，我们先使用到了它的DHCP Server功能，直接用apt就可以安装好dnsmasq了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install dnsmasq
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看一下dnsmasq的版本信息:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@debian:~# dnsmasq -v
Dnsmasq version 2.72  Copyright (c) 2000-2014 Simon Kelley
Compile time options: IPv6 GNU-getopt DBus i18n IDN DHCP DHCPv6 no-Lua TFTP conntrack ipset auth DNSSEC loop-detect
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很好，有ipset功能。下面我们修改dnsmasq的配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@debian:~# cat /etc/dnsmasq.conf 
interface=br0
dhcp-range=192.168.88.10,192.168.88.250,72h
conf-dir=/etc/dnsmasq.d/
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;interface为br0，表示让dnsmasq监听br0也就是我们的LAN接口，处理DNS和DHCP请求。&lt;/li&gt;
&lt;li&gt;dhcp-range表示了我们允许分配的地址范围，72h表示续期时间为72小时&lt;/li&gt;
&lt;li&gt;conf-dir表示这个目录下的文件也将作为dnsmasq的配置文件被读入，我们可以把其他的非路由核心功能的配置放到这个目录下&lt;/li&gt;
&lt;li&gt;具体给Dnsmasq配置哪些服务器用于解决DNS污染，是翻墙问题与搭建路由无关，这里就不说了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;/etc/init.d/dnsmasq restart重启dnsmasq服务，然后把电脑接入LAN2~LAN4接口，应该就会自动分配到IP了。&lt;/p&gt;
&lt;h3&gt;配置系统DNS&lt;/h3&gt;
&lt;p&gt;默认情况下，系统的dhcp client会自动从上游获取DNS Server，但是大部分情况下国内的上级DNS Server都是被污染的，除非你在我家偷接路由。&lt;/p&gt;
&lt;p&gt;我们可以通过一些技术手段来让Dnsmasq使用干净的DNS服务器并提供给LAN，但路由器本身的DNS确是被污染的，这会让你在路由器上进行一些涉及联网的操作变得很奇葩，所以我们希望把路由器本身的DNS也设置成Dnsmasq的127.0.0.1。&lt;/p&gt;
&lt;p&gt;这部很简单，只需要编辑/etc/dhcp/dhclient.conf文件，找到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#prepend domain-name-servers 127.0.0.1;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把前面的注释符号删掉，这样就会默认在/etc/resolv.conf中添加一个127.0.0.1的DNS服务器，也就是Dnsmasq的Server地址。&lt;/p&gt;
&lt;p&gt;然后找到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;request subnet-mask, broadcast-address, time-offset, routers,
        domain-name, domain-name-servers, host-name,
        netbios-name-servers, netbios-scope, interface-mtu;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把domain-name-servers删掉，表示不同dhcp服务器请求dns服务器地址，这样下次WAN再连上DHCP网络，/etc/resolv.conf就只有127.0.0.1这一个DNS服务器了。&lt;/p&gt;
&lt;h3&gt;上网&lt;/h3&gt;
&lt;p&gt;嗯，我们的路由器现在已经有了一个DNS服务(转发)器可以给我们解析域名，有了DHCP服务器可以给我们分配IP，甚至路由器本身也不用担心DNS污染了，唯一的问题是，我连上这个路由器后没法上网...&lt;/p&gt;
&lt;p&gt;这，好尴尬啊。&lt;/p&gt;
&lt;p&gt;其实路由器的核心功能，就是routing，也就是给联网请求选择通路。我们从LAN口接入，想要上网的话，就必须把从LAN口接收到的请求转发到WAN口上，再把从WAN口上收到的数据发回到LAN口，这不是就是NAT嘛，iptables就可以搞定！&lt;/p&gt;
&lt;h4&gt;配置IPtables转发&lt;/h4&gt;
&lt;p&gt;首先我们先清空可能存在的一起iptables规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后添加以下规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A FORWARD -i br0 -s 192.168.1.0/255.255.255.0 -j ACCEPT
iptables -A FORWARD -i eth0 -d 192.168.1.0/255.255.255.0 -j ACCEPT
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;前两条表示接受从br0和eth0接口输入的数据&lt;/li&gt;
&lt;li&gt;第三条表示把数据最终的POSTROUTING定向到eth0也就是WAN口上，使用MASQUERADE转译是为了保证NAT出去的地址是固定的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;使能IPV4转发&lt;/h4&gt;
&lt;p&gt;linux系统默认并没有开始ipv4和ipv6数据的转发，所以你光配置iptables转发是不被支持的，这里需要编辑/etc/sysctl.conf文件，找到:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#net.ipv4.conf.default.forwarding=1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把这个注释符删掉开启IPV4转发，但这个修改要重启后才生效，如果要立刻生效，直接使用以下的暴力命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;一些默认的防火墙安全规则&lt;/h4&gt;
&lt;p&gt;防火墙不能整天不务正业只顾着上网，至少应该有一些基本的安全规则，添加如下基本规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT
iptables -P FORWARD DROP
iptables -I INPUT 1 -i lo -j ACCEPT
iptables -I INPUT 1 -i br0 -j ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;固化Iptables规则&lt;/h4&gt;
&lt;p&gt;你可以用iptables-save和iptables-restore配合rc.local启动脚本来保存恢复防火墙规则，但其实有更简单的做法:iptables-persistent。&lt;/p&gt;
&lt;p&gt;直接apt-get install iptables-persistent就可以了，在安装的过程中就会询问你是否保存当前规则了，而且ipv4和ipv6的都会保存，虽然我们没用到后者。以后每次启动的时候iptables-persistent都会自动帮我们加载保存好的规则。&lt;/p&gt;
&lt;h2&gt;不服跑个分&lt;/h2&gt;
&lt;p&gt;如果我们费了这么大心思装好的路由最后的性能是个渣渣，那我们还用它干啥。所以我们来跑个分，在路由器上装好iperf3之后开启Server模式:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iperf -s -p 6000
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从macbook测试到路由器的速度：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;biqins-MBP:lifetyper.com lifetyper$ iperf3 -c debian -p 6000
Connecting to host debian, port 6000
[  6] local 192.168.88.165 port 52954 connected to 192.168.88.1 port 6000
[ ID] Interval           Transfer     Bandwidth
[  6]   0.00-1.00   sec   112 MBytes   938 Mbits/sec                  
[  6]   1.00-2.00   sec   112 MBytes   939 Mbits/sec                  
[  6]   2.00-3.00   sec   112 MBytes   939 Mbits/sec                  
[  6]   3.00-4.00   sec   112 MBytes   939 Mbits/sec                  
[  6]   4.00-5.00   sec   112 MBytes   939 Mbits/sec                  
[  6]   5.00-6.00   sec   112 MBytes   939 Mbits/sec                  
[  6]   6.00-7.00   sec   112 MBytes   939 Mbits/sec                  
[  6]   7.00-8.00   sec   112 MBytes   939 Mbits/sec                  
[  6]   8.00-9.00   sec   112 MBytes   940 Mbits/sec                  
[  6]   9.00-10.00  sec   112 MBytes   939 Mbits/sec                  
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  6]   0.00-10.00  sec  1.09 GBytes   939 Mbits/sec                  sender
[  6]   0.00-10.00  sec  1.09 GBytes   939 Mbits/sec                  receiver
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从另一个ubuntu主机测试到路由器的速度:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lifetyper@ubuntu:~$ iperf3 -c debian -p 6000
Connecting to host debian, port 6000
[  4] local 192.168.88.57 port 50410 connected to 192.168.88.1 port 6000
[ ID] Interval           Transfer     Bandwidth       Retr  Cwnd
[  4]   0.00-1.00   sec   107 MBytes   897 Mbits/sec    0    171 KBytes       
[  4]   1.00-2.00   sec   107 MBytes   896 Mbits/sec    0    188 KBytes       
[  4]   2.00-3.00   sec   107 MBytes   900 Mbits/sec    0    188 KBytes       
[  4]   3.00-4.00   sec   107 MBytes   896 Mbits/sec    0    205 KBytes       
[  4]   4.00-5.00   sec   107 MBytes   898 Mbits/sec    0    205 KBytes       
[  4]   5.00-6.00   sec   107 MBytes   899 Mbits/sec    0    205 KBytes       
[  4]   6.00-7.00   sec   107 MBytes   898 Mbits/sec    0    205 KBytes       
[  4]   7.00-8.00   sec   107 MBytes   901 Mbits/sec    0    205 KBytes       
[  4]   8.00-9.00   sec   107 MBytes   899 Mbits/sec    0    205 KBytes       
[  4]   9.00-10.00  sec   107 MBytes   900 Mbits/sec    0    205 KBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth       Retr
[  4]   0.00-10.00  sec  1.05 GBytes   898 Mbits/sec    0             sender
[  4]   0.00-10.00  sec  1.05 GBytes   898 Mbits/sec                  receiver

iperf Done.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后在ubuntu主机开启iperf3服务器，从macbook测网内两机器互访速度:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;biqins-MBP:lifetyper.com lifetyper$ iperf3 -c ubuntu -p 7000
Connecting to host ubuntu, port 7000
[  6] local 192.168.88.165 port 53144 connected to 192.168.88.57 port 7000
[ ID] Interval           Transfer     Bandwidth
[  6]   0.00-1.00   sec   105 MBytes   878 Mbits/sec                  
[  6]   1.00-2.00   sec   104 MBytes   871 Mbits/sec                  
[  6]   2.00-3.00   sec   104 MBytes   875 Mbits/sec                  
[  6]   3.00-4.00   sec   105 MBytes   878 Mbits/sec                  
[  6]   4.00-5.00   sec   105 MBytes   883 Mbits/sec                  
[  6]   5.00-6.00   sec   106 MBytes   889 Mbits/sec                  
[  6]   6.00-7.00   sec   104 MBytes   875 Mbits/sec                  
[  6]   7.00-8.00   sec   106 MBytes   885 Mbits/sec                  
[  6]   8.00-9.00   sec   106 MBytes   889 Mbits/sec                  
[  6]   9.00-10.00  sec   106 MBytes   892 Mbits/sec                  
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  6]   0.00-10.00  sec  1.03 GBytes   882 Mbits/sec                  sender
[  6]   0.00-10.00  sec  1.03 GBytes   881 Mbits/sec                  receiver

iperf Done.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;网内互访的速度肯定比直接连路由慢一点，不过平均882Mbps，在用上千兆网之前，基本不要啥自行车了。&lt;/p&gt;
&lt;h2&gt;资源使用情况&lt;/h2&gt;
&lt;p&gt;最后来看看这个路由到底需要多少资源：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@debian:/home/lifetyper# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        28G  2.0G   25G   8% /
udev             10M     0   10M   0% /dev
tmpfs           381M  5.2M  376M   2% /run
tmpfs           951M     0  951M   0% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           951M     0  951M   0% /sys/fs/cgroup
root@debian:/home/lifetyper# free -m
             total       used       free     shared    buffers     cached
Mem:          1900        139       1761          5         10         52
-/+ buffers/cache:         76       1824
Swap:         1285          0       1285
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2G的磁盘，139M的内存，CPU占用上我用top看，最高的CPU占用程序就是top本身。我本来以为磁盘占用会挺多的，没想到在安装完全部组件，并且把shadowsocks编译环境都搭完之后也才2G，难怪之前别人用edgerouter lite 2G的U盘就可以直接在路由上编译软件包了。&lt;/p&gt;
&lt;h3&gt;一些小贴士(不定期更新)&lt;/h3&gt;
&lt;h4&gt;给路由器一个名字&lt;/h4&gt;
&lt;p&gt;如果你不想每次ssh到路由的时候都输一串ip，其实我们完全可以给路由器一个名称，直接通过主机名来访问它。
这个很简单，直接修改/etc/hosts文件就可以了，因为dnsmasq是会从这里读取主机名的，读取之后主机名对于dnsmasq来说就像LAN里的主机一样是可以直接解析的，我们在/etc/hosts中添加:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;192.168.88.1        debian
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重启dnsmasq之后，我们就可以用类似ssh user@debian的方式登录路由了。&lt;/p&gt;
&lt;h4&gt;添加用户到sudo组&lt;/h4&gt;
&lt;p&gt;默认新建的非root用户权限很低，安装了sudo之后也因为默认不在sudo组内所以不能使用sudo命令，解决方法就是先用root登录，然后执行以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install sudo
adduser your_user_name sudo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;退出之后再用刚才添加的用户名登录，就可以使用sudo了，如果有太多sudo命令要做，直接&lt;code&gt;sudo bash&lt;/code&gt;就可以切到root用户了。&lt;/p&gt;</content></entry><entry><title>Initial</title><link href="posts/blog_initial.html" rel="alternate"></link><published>2017-03-03T14:32:12+08:00</published><updated>2017-03-03T14:32:12+08:00</updated><author><name>毕勤</name></author><id>tag:None,2017-03-03:posts/blog_initial.html</id><summary type="html">&lt;p&gt;因为实在不知道怎么给这个场景取标题了，也不记得是这里第几次自杀后重生了。没有丢数据，也没有任何其他的问题，只是忽然觉得一个blog要配置php，要配置mysql，要配置nginx来支持实在太多余。我想要一个可以随便找块磁盘就可以完整备份全站，随便找个空间上传一下就可以重新部署的系统，一个像latex一样合理的受代码精准控制格式的撰写语言，另外我要看得懂他们系统的语言，所以是pelican...&lt;/p&gt;</summary><content type="html">&lt;p&gt;因为实在不知道怎么给这个场景取标题了，也不记得是这里第几次自杀后重生了。&lt;/p&gt;
&lt;p&gt;没有丢数据，也没有任何其他的问题，只是忽然觉得一个blog要配置php，要配置mysql，要配置nginx来支持实在太多余。我想要一个可以随便找块磁盘就可以完整备份全站，随便找个空间上传一下就可以重新部署的系统，一个像latex一样合理的受代码精准控制格式的撰写语言，另外我要看得懂他们系统的语言，所以是&lt;a href="https://blog.getpelican.com/"&gt;pelican&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;昨天看了一下才发现lifetyper.com这个域名竟然注册了快10年了,就连域名的灵感来源lifetype.net都接近半死状态了，论坛很多板块多年没人发言，有也就是一两年偶尔有人冒个泡。&lt;/p&gt;
&lt;p&gt;至于用lifetype的人，hipeople跳转到了小程序，秋月白不知道毕业后在干啥，winman也不在&lt;a href="http://forum.lifetype.org.cn/"&gt;lifetype中文论坛&lt;/a&gt;上线好久好久了。&lt;/p&gt;
&lt;p&gt;Vick不知道是否还有空打游戏，杨康不知道一年回几次国，Yee在我脑子里还是那张年轻的脸，虽然实际上应该和我一样差不多到了而立之年，晓慧姐，我真的应该找个时间去喝杯咖啡，虽然我喝了咖啡就犯困。&lt;/p&gt;
&lt;p&gt;还有些人，我连名字甚至ID都不记得了。&lt;/p&gt;
&lt;p&gt;blog曾经是个那么火的东西，现在却让人一度怀疑个人是否真的有写blog表达自我的需求，曾经那些几百万注册量的博客网站可是web2.0时代最大的内容制造者呢。现在，假的让我怀疑自己经历的是个梦，纵然房价在十年内涨了5678倍也没让我有这样的感受。&lt;/p&gt;
&lt;p&gt;我们到底要写什么呢？&lt;/p&gt;
&lt;p&gt;写日记？真的会有人喜欢公开自己的隐私吗，或者说，谁会在乎你的隐私，除了你的暗恋者。作为家庭的记录也许是不错的，但你写了几百个字可能是为了贴出一张照片或者一段视频，blog就是个脚注。所以，可能等你老了想写回忆录却又没有任何媒体的时候，blog才有点用，就当是写本书好了。&lt;/p&gt;
&lt;p&gt;写技术文章？我早就不会干全文复制这种勾当了，但写的无非也就是从网上获得的别人的知识经过我消化之后的产物，原始内容的生产有却很少。牛很了不起，吃的是草挤的是奶，但如果连草都没有呢？挖煤也很不错，但如果连产生煤矿的远古树木都没有呢？&lt;/p&gt;
&lt;p&gt;只有太阳是伟大的。大部分blogger活在一个“我写东西会有人看，会对社会主义四个现代化建设作出伟大贡献”的幻觉中。如果保持这种幻觉，我可以假装成一个思想家在这里叨叨。&lt;/p&gt;
&lt;p&gt;把无序的文字组织起来写成文章，是一种让熵减小的做法，而我这次的作为，到底还是符合了宇宙的熵不断无限增大的定势，我开始理解我朋友第一次看到熵增原理时的那种伤感。&lt;/p&gt;
&lt;p&gt;人类虽然可以通过自己的努力在小范围内不断的减小熵值，构建美妙的产物，但这些产物最终还是会消亡，逃都逃不掉，甚至于文章这样对实体依赖极小的东西也不能幸免。&lt;/p&gt;
&lt;p&gt;按香农的说法，越少的、存在概率越低的东西信息量越大，但对于信息而言，副本越少越不安全，所以人类出于对珍贵信息保护的本能会去复制粘贴优秀的文章，由此可证，如果我的文章在其他地方都找不到副本，那也没什么存在的必要。&lt;/p&gt;
&lt;p&gt;你说呢？谦益。&lt;/p&gt;</content></entry></feed>